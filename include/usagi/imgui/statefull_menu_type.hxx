#include <imgui.h>

#include <boost/algorithm/string/split.hpp>

#include <map>
#include <stack>
#include <string>
#include <functional>
#include <random>
#include <cstddef>

namespace usagi
{
  namespace imgui
  {
    /// @brief ImGui の menu 系 API のステートフルラッパー
    /// add( value_type( "",  ), ... )
    template < typename FUNCTOR_TYPE = void >
    struct statefull_menu_type
    {
      using functor_type = std::function< auto () -> void >;//FUNCTOR_TYPE;
      using value_type = std::pair< std::string, functor_type >;
      using self_type = statefull_menu_type< functor_type >;
      
      statefull_menu_type()
        : _root_node_label
          ( "##" + std::to_string( generate_random_number() )
          )
      { }
      
      auto show() { _show = true; }
      
      /// @brief open the context menu
      auto operator()()
        -> std::unique_ptr< std::string >
      {
        if ( _is_popup )
        {
          if ( ImGui::BeginPopup( _root_node_label.c_str() ) )
          {
            recursive_menu_render( _m );
            ImGui::EndPopup();
          }
          
          if ( _show )
            ImGui::OpenPopup( _root_node_label.c_str() );
        }
        else
          recursive_menu_render( _m );
        
        return { };
      }
      
      auto remove( const std::string& concatenated_path )
      {
        const auto path_parts = split( concatenated_path );
        
        auto m = &_m;
        
        std::stack
        < std::pair
          < recursive_mapper_type*
          , typename recursive_mapper_type::iterator
          >
        > erase_candidates;
        
        for ( const auto p : path_parts )
        {
          const auto i = m->find( p );
          
          if ( i == cend( *m ) )
            throw std::runtime_error( "usagi::imgui::statefull_menu_type::remove: cannot find the given path `" + concatenated_path + "`." );
          
          erase_candidates.emplace( std::make_pair( m, i ) );
          
          m = &i->second;
        }
        
        for ( auto* p = &erase_candidates.top(); not erase_candidates.empty(); erase_candidates.pop(), p = &erase_candidates.top() )
        {
          if ( not p->second->second.empty() )
            break;
          
          p->first->erase( p->second );
        }
      }
      
      template < typename ... T >
      auto add( const value_type& head, const T ... tails )
        -> void
      {
        add( head );
        add( tails ... );
      }
      
      auto add( const value_type& head )
        -> void
      {
        add( head.first, head.second );
      }
      
      /// @param path eg. "xxx/yyy/zzz" then xxx and yyy are intermediary node its like a directory, and zzz is marginal leaf node.
      /// @note you can change a path separator to use `path_separator( "your-separator" )`.
      auto add( const std::string& concatenated_path, const std::function< auto () -> void >& f )
        -> void
      {
        const auto path_parts = split( concatenated_path );
        
        auto m = &_m;
        
        for ( const auto p : path_parts )
        {
          const auto i = m->find( p );
          if ( i == cend( *m ) )
          {
            bool is_succeeded = false;
            typename recursive_mapper_type::iterator inserted;
            
            std::tie( inserted, is_succeeded ) = m->emplace( p, recursive_mapper_type( f ) );
            
            if ( not is_succeeded )
              throw std::runtime_error( "usagi::imgui::statefull_menu_type::add_menu_path: failed. given path are: " + concatenated_path );
            
            m = &inserted->second;
          }
          else
            m = &i->second;
        }
      }
      
      /// @note default label will be "##xxxxxx", `xxxxxx` is a random number generated by mt19937_64 and random-device's seed.
      auto root_node_label() { return _root_node_label; }
      auto root_node_label( const std::string& in ) { return _root_node_label = in; }
      auto root_node_label( std::string&& in ) { return _root_node_label = std::forward< std::string >( in ); }
      
      auto path_separator() { return _path_separator; }
      auto path_separator( const std::string& in ) { return _path_separator = in; }
      auto path_separator( std::string&& in ) { return _path_separator = std::forward< std::string >( in ); }
      
      auto is_popup() { return _is_popup; }
      auto is_popup( const bool in ) { return _is_popup = in; }
      
      auto empty() { return _m.empty(); }
      
    private:
      
      auto split( const std::string& in ) -> std::vector< std::string >
      {
        std::vector< std::string > r;
        boost::algorithm::split( r, in, boost::is_any_of( _path_separator ) );
        return r;
      }
      
      static auto generate_random_number() -> std::mt19937_64::result_type
      {
        static std::random_device rnd;
        static std::mt19937_64 rne( rnd() );
        return rne();
      }
      
      using indices_type = std::vector< std::size_t >;
      struct recursive_mapper_type;
      using internal_mapper_type = std::map< std::string, recursive_mapper_type >;
      struct recursive_mapper_type
        : public internal_mapper_type
      {
        recursive_mapper_type() { }
        explicit recursive_mapper_type( const functor_type& f ) : _f( f ) { }
        explicit recursive_mapper_type( functor_type&& f ) : _f( std::forward< functor_type >( f ) ) { }
        auto operator()() const { _f(); }
        functor_type _f;
      };
      
      auto recursive_menu_render( const recursive_mapper_type& m )
        -> void
      {
        if ( m.empty() )
          return;
        
        for ( const auto p : m )
        {
          if ( p.second.empty() )
          {
            if ( ImGui::MenuItem( p.first.c_str(), "", false ) )
            {
              p.second();
              _show = false;
            }
          }
          else
          {
            if ( ImGui::BeginMenu( p.first.c_str() ) )
            {
              recursive_menu_render( p.second );
              ImGui::EndMenu();
            }
          }
        }
      }
      
      /// @brief internal recursive mapper
      recursive_mapper_type _m;
      
      std::string _root_node_label;
      std::string _path_separator = "/";
      bool _is_popup = true;
      bool _show = false;
    };
    
  }
}
